"estimate" <- function(data, h1 = NULL, h2 = NULL, h11 = NULL, xvals = NULL, B = 99., add = 1., D = 1., brief = T){	#       Date:  5.3.98	#       ESTIMATION OF FREQUENCY DISTRIBUTION FROM TWO BIASED SAMPLES
        #       Author: Lloyd, C.J. and Jones, M.C. (2000)
        #               Nonparametric density estimation from biased data with unknown biasing function
        #               JASA, 95, 865-876
        #
        #       This makes a key assumption that the biasing function is the same in both samples.	#	#       REQUIRED ARGUMENTS:	#                 data - containing components $x1, $x2, $x11 all non-empty	#	#       OPTIONAL ARGUMENTS:	#            h1,h2,h11 - three non-negative bandwidths. If these are not	#                        supplied an automatic bandwdith selector is used.	#                 xvals - grid of values at which to estimate N(x)=Nf(x)	#                  add - adding 1 solves numerical instability in the extremes	#                    D - D>1 undersmooths, D<1 oversmooths	#	#       VALUE:	#       Object with components	#           y - estimated frequency N(x)	#           x - grid of points at which N(x) is estimated	#          NP - Petersen estimator	#        seNP - standard error of NP (assuming homogeneity)	#           N - estimate from integrating N(x)	#         seN - standard error of N	#           h - the bandwidths h1, h2, h11	#          p1 - estimate of first weight function	#          p2 - estimate of second weight function	#       brief - if TRUE then no plotted output	#	#	#       The function "plugin" is an automatic bandwidth selector	value <- NULL	#	#       If no bandwidths, select bandwidths for each sample	plugin <- function(x, B = min(length(x) + 3., 49.), prin = T)	{		n <- length(x)		grid <- function(x, n)		{			min(x, na.rm = T) + (-1.:(n + 1.))/n * (max(x, na.rm = T) - min(x, na.rm = T))		}		xx <- grid(x, B - 3.)		X <- matrix(rep(xx, rep(B, B)), ncol = B)		X <- X - t(X)		counts <- hist(x, breaks = grid(x, B - 2.), plot = F)$counts		k <- matrix(rep(counts, rep(B, B)), ncol = B)		k <- k * #		t(k)		qs <- quantile(x, na.rm = T)		s <- (qs[4.] - qs[2.])/1.3400000000000001		names(s) <- NULL		psi8 <- signif(1.851/s^9., 3.)		h <- (1.23 * s)/n^(1./9.)		h3 <- signif(h, 3.)		XX <- X/h		psi6 <- abs(sum(k * (XX^6. - 15. * XX^4. + 45. * XX^2. - 15.) * dnorm(XX))/(n^2. * h^7.))		h <- (2.3940000000000001/(psi6 * n))^(1./7.)		h2 <- signif(h, 3.)		XX <- X/h		psi4 <- abs(sum(k * (XX^4. - 6. * XX^2. + 3.) * dnorm(XX))/(n^2. * h^5.))		h1 <- signif((0.28199999999999997/(psi4 * n))^(1./5.), 3.)		if(prin) {			print(paste("Psi values used: ", psi8, signif(psi6, 3.), signif(psi4, 3.)))			print(paste("Bandwidths used: ", h3, h2, h1))		}		h1	}	x1 <- data$x1	x2 <- data$x2	x11 <- data$x11	if(missing(h1)) {		h1 <- plugin(x1)/D	}	if(missing(h2)) {		h2 <- plugin(x2)/D	}	if(missing(h11)) {		h11 <- plugin(x11)/D	}	h <- sqrt(h1 * h2)	x <- c(x1, x2, x11)	#       The function "eta" is a kernel frequency distribution estimator	if(missing(xvals)) {		xvals <- min(x) - 4. * h + (1.:B)/(B + 1.) * (max(x) - min(x) + 8. * h)	}	eta <- function(x, h, xx = NULL, B = 99.)	{		value <- NULL		if(missing(xx)) {			xx <- min(x) - 4. * h + (1.:B)/(B + 1.) * (max(x) - min(x) + 8. * h)		}		n <- length(x)		m <- length(xx)		X <- matrix(rep(x, rep(m, n)), ncol = m, byrow = T) - matrix(rep(xx, rep(n, m)), ncol = m)		value$y <- apply(matrix(dnorm( - X, sd = h), ncol = m), 2., sum)		value$x <- xx		value	}	n1 <- length(x1)	n2 <- length(x2)	n11 <- length(x11)	eta1 <- eta(x1, h, xx = xvals, B = B)$y	eta2 <- eta(x2, h, xx = xvals, B = B)$y	eta11 <- eta(x11, h11, xx = xvals, B = B)$y	delta <- mean(diff(xvals))	Nxhat <- ((eta1 + add/h) * (eta2 + add/h))/(eta11 + add/h11)	Nhat <- signif(sum(Nxhat * delta), 4.)	p1 <- (eta11 + add/h11)/(eta1 + add/h)	p2 <- (eta11 + add/h11)/(eta2 + add/h)	p <- sqrt(p1 * p2)	p[p > 1.] <- 1.	th <- h11/h	v <- (2. * p^2. + 2. * p + 1./th)/sqrt(2. * pi) - 4./sqrt(2. * pi * (1. + th^2.)) * p	v <- (v * Nxhat)/h/p^2.	seN <- Nxhat * (1. - 1./p)^2.	#	#       Output results into object value	if(!brief) {		par(mfrow = c(3., 2.))		plot(xvals, eta1)		plot(xvals, eta2)		plot(xvals, eta11)
                plot(xvals, Nxhat)		plot(range(xvals), range(c(p1, p2)), type = "n", xlab = "")		lines(xvals, p)		lines(xvals, p1, lty = 2.)		lines(xvals, p2, lty = 2.)		print(sum(eta1 * delta))		print(sum(eta2 * delta))		print(sum(eta11 * delta))	}	value$x <- xvals	value$y <- signif(Nxhat, 4.)	value$sey <- sqrt(v)	value$NP <- signif((sqrt(n1 * n2) + 1.)^2./(n11 + 1.), 4.)	value$seNP <- signif(sqrt((n1 * n2)/n11) * abs(1. - sqrt(n1 * n2)/n11), 3.)	value$N <- signif(Nhat, 4.)	value$seN <- signif(sqrt(sum(seN * delta)), 3.)	value$r <- n1 + n2 - n11	value$h <- signif(c(h, h11), 3.)	value$p <- signif(p, 3.)	value}